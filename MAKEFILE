##############################################################
# Makefile for building and testing Nebulite
##############################################################

##################################
# Base CMake Presets Build Targets
##################################

# We define presets one by one,
# otherwise some linters complain about unresolved prerequisites later on

linux-release:
	@echo "Building preset: $@"
	@cmake --preset $@
	@cmake --build --preset $@ -j4

linux-debug:
	@echo "Building preset: $@"
	@cmake --preset $@
	@cmake --build --preset $@ -j4

linux-coverage:
	@echo "Building preset: $@"
	@cmake --preset $@
	@cmake --build --preset $@ -j4

windows-release:
	@echo "Building preset: $@"
	@cmake --preset $@
	@cmake --build --preset $@ -j4

windows-debug:
	@echo "Building preset: $@"
	@cmake --preset $@
	@cmake --build --preset $@ -j4

macos-release:
	@echo "Building preset: $@"
	@cmake --preset $@
	@cmake --build --preset $@ -j4

macos-debug:
	@echo "Building preset: $@"
	@cmake --preset $@
	@cmake --build --preset $@ -j4

##################################
# Native and Available Presets
##################################


# Find native build preset for this machine
UNAME_S := $(shell uname -s)
ifeq ($(UNAME_S),Linux)
	NATIVE_PRESET := linux-release linux-debug linux-coverage
else ifeq ($(UNAME_S),Darwin)
	NATIVE_PRESET := macos-release macos-debug
else ifeq ($(OS),Windows_NT)
	NATIVE_PRESET := windows-release windows-debug
else
	NATIVE_PRESET := linux-release linux-debug linux-coverage
endif

# Find available presets for this machine based on OS and compilers available
# We consider NATIVE_PRESET as well as any cross-compilation presets possible
# Currently, we only check if wine and mingw are available for Windows cross-compilation
AVAILABLE_PRESETS := $(NATIVE_PRESET)
ifeq ($(UNAME_S),Linux)
# check for wine and mingw availability
# if available, add windows presets
ifneq ($(shell command -v wine 2> /dev/null),)
ifneq ($(shell command -v x86_64-w64-mingw32-g++ 2> /dev/null),)
	# add windows presets
	AVAILABLE_PRESETS += windows-release windows-debug
endif
endif
endif

# Define target "all" as building all available presets
all: $(AVAILABLE_PRESETS)


##################################
# Define other useful targets
##################################

.PHONY: all install-deps resources test run clean $(NATIVE_PRESET)

install-deps:
	@./Scripts/install_dependencies.sh

resources:
	@./Scripts/AssetCreation/create_resources_directory.sh

test:
	@python3 Scripts/TestingSuite.py --stop --verbose

clean:
	@rm -rf tmp/ bin/ || true

message-available-presets:
	@echo "Available presets for this machine: $(AVAILABLE_PRESETS)"

coverage-report:
	@echo "Generating coverage report..."
	@python Scripts/TestingSuite.py --coverage --verbose

delete-binaries:
	@rm -rf bin/* || true

##################################
# Debugging
##################################

# TODO: Implement debugging targets from .vscode/launch.json


##################################
# Build
##################################

# Fast build targets for native and available presets

build-native: $(NATIVE_PRESET)

build-available: $(AVAILABLE_PRESETS) message-available-presets

build-coverage: linux-coverage coverage-report

# Clean build targets for native and available presets

clean-build-native: clean build-native

clean-build-available: clean build-available

##################################
# Full testing pipelines
##################################

# Non-clean build + test

build-and-test-native: delete-binaries build-native test

build-and-test-available: delete-binaries build-available test

# Clean build + test

clean-build-and-test-native: clean-build-native test

clean-build-and-test-available: clean-build-available test

# Coverage build + report

clean-build-and-test-coverage: clean build-coverage coverage-report

##################################
# Debug
##################################

debug-linux:
	@echo "Starting non-interactive debugger (prints backtrace on crash)..."
	@ulimit -c unlimited && gdb -batch -ex "set pagination 0" -ex "run" -ex "bt full" --args ./bin/Nebulite_Debug task TaskFiles/Debugging/debug.nebs

debug-linux-interactive:
	@echo "Starting interactive debugger for native preset..."
	@gdb --args ./bin/Nebulite_Debug task TaskFiles/Debugging/debug.nebs


##################################
# Profiling, Benchmarking, etc.
##################################

# TODO: Implement profiling and similar targets from .vscode/tasks.json

cli-lint:
	@echo "Running CLI linter..."
	@./Scripts/Validation/runClangTidy.sh
	@echo "CLI linting completed."

profiling-small:
	@echo "Running small profiling suite..."
	@sudo sysctl -w kernel.perf_event_paranoid=-1 ; sudo sysctl -w kernel.kptr_restrict=0 && perf record -F 99 -g -- ./bin/Nebulite_Debug task TaskFiles/Benchmarks/spawn_constantly.nebs ; hotspot perf.data
	@echo "Small profiling completed."

profiling-large:
	@echo "Running large profiling suite..."
	@sudo sysctl -w kernel.perf_event_paranoid=-1 ; sudo sysctl -w kernel.kptr_restrict=0 && perf record -F 99 -g -- ./bin/Nebulite_Debug task TaskFiles/Benchmarks/gravity_XL.nebs ; hotspot perf.data
	@echo "Large profiling completed."

memory-check-gui:
	@echo "Running memory check with Valgrind..."
	@rm -rf massif_output.out ; ulimit -n 32768 && valgrind --tool=massif --massif-out-file=massif_output.out --max-snapshots=500 --detailed-freq=1 ./bin/Nebulite_Debug task TaskFiles/Debugging/memoryleak.nebs && massif-visualizer massif_output.out
	@echo "Memory check completed."

memory-check-cli:
	@echo "Running memory check with Valgrind..."
	@ulimit -n 32768 && valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./bin/Nebulite_Debug task TaskFiles/Debugging/memoryleak.nebs
	@echo "Memory check completed. See valgrind_output.txt for details."

##################################
# Commit testing pipelines
##################################

# Checks if there are any changes in the code since the last run
# If there are, runs the full testing pipeline on native presets
# 1.) Check sources last modified times against tmp/.lastModified
# 2.) If any changes, run full testing pipeline on native presets
# 3.) Update tmp/.lastModified file
# - Shows last modified file at the end

WATCH_DIRS := src Scripts TaskFiles include
LAST_MOD_FILE := tmp/.lastModified
ROOT_DIR := $(realpath $(dir $(lastword $(MAKEFILE_LIST))))

commit-test-pipeline:
	@echo "Checking sources for changes in: $(WATCH_DIRS)"
	@mkdir -p tmp
	@echo "Finding last modified time..."
	@find $(WATCH_DIRS) -type f -exec stat -c '%Y %n' {} + | sort -nr | head -n 1 > tmp/.latest
	@if [ ! -f $(LAST_MOD_FILE) ]; then \
		echo "No previous timestamp file found. Running full pipeline..."; \
		cd $(ROOT_DIR) && $(MAKE) -f $(lastword $(MAKEFILE_LIST)) build-and-test-native; \
	else \
		latest=$$(cut -d' ' -f1 tmp/.latest); \
		last=$$(cat $(LAST_MOD_FILE)); \
		if [ $$latest -gt $$last ]; then \
			echo "Changes detected. Running full pipeline in $(ROOT_DIR)"; \
			cd $(ROOT_DIR) && $(MAKE) -f $(lastword $(MAKEFILE_LIST)) build-and-test-native; \
		else \
			echo "No changes detected. Skipping tests."; \
		fi; \
	fi
	@cut -d' ' -f2- tmp/.latest | xargs -I{} echo "Last modified file: {}"
	@cut -d' ' -f1 tmp/.latest > $(LAST_MOD_FILE)




