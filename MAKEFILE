##############################################################
# Makefile for building Nebulite with CMake presets
##############################################################

##################################
# Base CMake Presets Build Targets
##################################

# We define presets one by one,
# otherwise some linters complain about unresolved prerequisites later on

linux-release:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

linux-debug:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

linux-coverage:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

windows-release:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

windows-debug:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

macos-release:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

macos-debug:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

##################################
# Native and Available Presets
##################################


# Find native build preset for this machine
UNAME_S := $(shell uname -s)
ifeq ($(UNAME_S),Linux)
	NATIVE_PRESET := linux-release linux-debug linux-coverage
else ifeq ($(UNAME_S),Darwin)
	NATIVE_PRESET := macos-release macos-debug
else ifeq ($(OS),Windows_NT)
	NATIVE_PRESET := windows-release windows-debug
else
	NATIVE_PRESET := linux-release linux-debug linux-coverage
endif

# Find available presets for this machine based on OS and compilers available
# We consider NATIVE_PRESET as well as any cross-compilation presets possible
# Currently, we only check if wine and mingw are available for Windows cross-compilation
AVAILABLE_PRESETS := $(NATIVE_PRESET)
ifeq ($(UNAME_S),Linux)
# check for wine and mingw availability
# if available, add windows presets
ifneq ($(shell command -v wine 2> /dev/null),)
ifneq ($(shell command -v x86_64-w64-mingw32-g++ 2> /dev/null),)
	# add windows presets
	AVAILABLE_PRESETS += windows-release windows-debug
endif
endif
endif

# Define target "all" as building all available presets
all: $(AVAILABLE_PRESETS)


##################################
# Define other useful targets
##################################

.PHONY: all install-deps resources test run clean $(NATIVE_PRESET)

install-deps:
	./Scripts/install_dependencies.sh

resources:
	./Scripts/AssetCreation/create_resources_directory.sh

test:
	python3 Scripts/TestingSuite.py --stop --verbose

clean:
	rm -rf tmp/ bin/ || true

message-available-presets:
	@echo "Available presets for this machine: $(AVAILABLE_PRESETS)"

coverage-report: linux-coverage
	@echo "Generating coverage report..."
	python Scripts/TestingSuite.py --coverage --verbose

delete-binaries:
	rm -rf bin/* || true

##################################
# Debugging
##################################

# TODO: Implement debugging targets from .vscode/launch.json


##################################
# Build
##################################

build-native: $(NATIVE_PRESET)

build-available: message-available-presets $(AVAILABLE_PRESETS)

##################################
# Full testing pipelines
##################################

# Non-clean build

build-and-test-native: delete-binaries build-native test

build-and-test-available: delete-binaries build-available test

# Clean build

clean-build-and-test-native: clean build-native test

clean-build-and-test-available: message-available-presets clean build-available test

##################################
# Profiling and benchmarking targets
##################################

# TODO: Implement profiling and similar targets from .vscode/tasks.json

##################################
# Commit testing pipelines
##################################

# Checks if there are any changes in the code since the last run
# If there are, runs the full testing pipeline on native presets
# 1.) Check sources last modified times against tmp/.lastModified
# 2.) If any changes, run full testing pipeline on native presets
# 3.) Update tmp/.lastModified file
# - Shows last modified file at the end

WATCH_DIRS := src Scripts TaskFiles include
LAST_MOD_FILE := tmp/.lastModified
ROOT_DIR := $(realpath $(dir $(lastword $(MAKEFILE_LIST))))

commit-test-pipeline:
	@echo "Checking sources for changes in: $(WATCH_DIRS)"
	@mkdir -p tmp
	@echo "Finding last modified time..."
	@find $(WATCH_DIRS) -type f -exec stat -c '%Y %n' {} + | sort -nr | head -n 1 > tmp/.latest
	@if [ ! -f $(LAST_MOD_FILE) ]; then \
		echo "No previous timestamp file found. Running full pipeline..."; \
		cd $(ROOT_DIR) && $(MAKE) -f $(lastword $(MAKEFILE_LIST)) build-and-test-native; \
	else \
		latest=$$(cut -d' ' -f1 tmp/.latest); \
		last=$$(cat $(LAST_MOD_FILE)); \
		if [ $$latest -gt $$last ]; then \
			echo "Changes detected. Running full pipeline in $(ROOT_DIR)"; \
			cd $(ROOT_DIR) && $(MAKE) -f $(lastword $(MAKEFILE_LIST)) build-and-test-native; \
		else \
			echo "No changes detected. Skipping tests."; \
		fi; \
	fi
	@cut -d' ' -f2- tmp/.latest | xargs -I{} echo "Last modified file: {}"
	@cut -d' ' -f1 tmp/.latest > $(LAST_MOD_FILE)




