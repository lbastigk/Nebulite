##############################################################
# Makefile for building Nebulite with CMake presets
##############################################################

##################################
# Base CMake Presets Build Targets
##################################

# We define presets one by one,
# otherwise some linters complain about unresolved prerequisites later on

linux-release:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

linux-debug:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

linux-coverage:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

windows-release:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

windows-debug:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

macos-release:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

macos-debug:
	@echo "Building preset: $@"
	cmake --preset $@
	cmake --build --preset $@

##################################
# Native and Available Presets
##################################


# Find native build preset for this machine
UNAME_S := $(shell uname -s)
ifeq ($(UNAME_S),Linux)
	NATIVE_PRESET := linux-release linux-debug linux-coverage
else ifeq ($(UNAME_S),Darwin)
	NATIVE_PRESET := macos-release macos-debug
else ifeq ($(OS),Windows_NT)
	NATIVE_PRESET := windows-release windows-debug
else
	NATIVE_PRESET := linux-release linux-debug linux-coverage
endif

# Find available presets for this machine based on OS and compilers available
# We consider NATIVE_PRESET as well as any cross-compilation presets possible
# Currently, we only check if wine and mingw are available for Windows cross-compilation
AVAILABLE_PRESETS := $(NATIVE_PRESET)
ifeq ($(UNAME_S),Linux)
# check for wine and mingw availability
# if available, add windows presets
ifneq ($(shell command -v wine 2> /dev/null),)
ifneq ($(shell command -v x86_64-w64-mingw32-g++ 2> /dev/null),)
	# add windows presets
	AVAILABLE_PRESETS += windows-release windows-debug
endif
endif
endif

# Define target "all" as building all available presets
all: $(AVAILABLE_PRESETS)


##################################
# Define other useful targets
##################################

.PHONY: all install-deps resources test run clean $(NATIVE_PRESET)

install-deps:
	./Scripts/install_dependencies.sh

resources:
	./Scripts/AssetCreation/create_resources_directory.sh

test:
	python3 Scripts/TestingSuite.py --stop --verbose

clean:
	rm -rf tmp/ bin/ || true

message-available-presets:
	@echo "Available presets for this machine: $(AVAILABLE_PRESETS)"

coverage-report: linux-coverage
	@echo "Generating coverage report..."
	python Scripts/TestingSuite.py --coverage --verbose

delete-binaries:
	rm -rf bin/* || true

##################################
# Debugging
##################################

# TODO: Implement debugging targets from .vscode/launch.json




##################################
# Full testing pipelines
##################################

# Non-clean build

run-and-test-native: delete-binaries $(NATIVE_PRESET) test

run-and-test-available: message-available-presets delete-binaries $(AVAILABLE_PRESETS) test

# Clean build

clean-run-and-test-native: clean $(NATIVE_PRESET) test

clean-run-and-test-available: message-available-presets clean $(AVAILABLE_PRESETS) test

##################################
# Profiling and benchmarking targets
##################################

# TODO: Implement profiling and similar targets from .vscode/tasks.json

##################################
# Commit testing pipelines
##################################

# Checks if there are any changes in the code since the last run
# If there are, runs the full testing pipeline on native presets
# 1.) Check sources last modified times against tmp/.lastModified
# 2.) If any changes, run full testing pipeline on native presets
# 3.) Update tmp/.lastModified file

WATCH_DIRS := src Scripts Tests include Resources
commit-test-pipeline:
	@echo "Checking sources for changes in: $(WATCH_DIRS)"
	@dirs=$$(for d in $(WATCH_DIRS); do [ -d "$$d" ] && printf "%s " "$$d"; done); \
	if [ -z "$$dirs" ]; then \
		echo "No watch directories exist. Skipping."; \
		exit 0; \
	fi; \
	EXCLUDE=".git .idea .vscode tmp bin build node_modules"; \
	# build the prune expression like: \( -path '*/.git/*' -o -path '*/.idea/*' \) -prune -o
	prune_expr=""; \
	for e in $$EXCLUDE; do prune_expr="$$prune_expr -o -path '*/$$e/*'"; done; \
	# run find limited to WATCH_DIRS and applying the prune expression, then get newest mtime+path
	latest_info=$$(eval "find $$dirs \\( $${prune_expr# -o} \\) -prune -o -type f -print0" 2>/dev/null | \
	  xargs -0 stat -c '%Y %n' 2>/dev/null | sort -n | tail -n1); \
	if [ -z "$$latest_info" ]; then \
		echo "No files found in $$dirs after exclusions. Skipping."; \
		exit 0; \
	fi; \
	latest_time=$$(printf "%s" "$$latest_info" | awk '{print $$1}'); \
	latest_file=$$(printf "%s" "$$latest_info" | cut -d' ' -f2-); \
	echo "Latest modified file: $$latest_file (mtime: $$latest_time)"; \
	if [ -f tmp/.lastModified ]; then last=$$(cat tmp/.lastModified); else last=0; fi; \
	if [ "$$latest_time" -gt "$$last" ]; then \
		echo "Changes detected (new: $$latest_time > old: $$last). Running full testing pipeline..."; \
		$(MAKE) -f $(abspath $(lastword $(MAKEFILE_LIST))) -C $(CURDIR) run-and-test-native || { echo "Pipeline failed"; exit 1; }; \
		date +%s > tmp/.lastModified; \
		echo "tmp/.lastModified updated."; \
	else \
		echo "No changes since tmp/.lastModified ($$last)."; \
	fi

